Help on module threaded:

NAME
    threaded - threaded multitasking

FILE
    threaded/threaded.py

CLASSES
    Synchronized
    Task
        IterableTask
    TaskInfo
    Threaded
        Blocking
        Slaving
            Pipelining
    
    class Blocking(Threaded)
     |  block until a task can be executed
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args, **kwargs)
     |  
     |  put(self, task, *args, **kwargs)
     |      block until the task can be executed
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Threaded:
     |  
     |  get(self)
     |      if queue_output was specified, return a TaskInfo instance
    
    class IterableTask(Task)
     |  an interface for a multipart task
     |  
     |  note that __call__ and next don't accept arguments
     |  
     |  Methods defined here:
     |  
     |  __call__(self)
     |      execute the entire task
     |  
     |  __init__(self)
     |  
     |  __iter__(self)
     |  
     |  next(self)
     |      execute the next part of the task
    
    class Pipelining(Slaving)
     |  pipeline iterable tasks among the slaves
     |  
     |  Method resolution order:
     |      Pipelining
     |      Slaving
     |      Threaded
     |  
     |  Methods defined here:
     |  
     |  __init__(self, nthreads=1)
     |  
     |  put(self, iterable_task)
     |      add an iterable task to the queue
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Slaving:
     |  
     |  kill_all(self)
     |      attempt to gracefully kill the slaves
     |  
     |  start(self)
     |      set alive to True and start the slaves
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Threaded:
     |  
     |  get(self)
     |      if queue_output was specified, return a TaskInfo instance
    
    class Slaving(Threaded)
     |  handle tasks among a finite (positive) number of slaves
     |  
     |  because threads are tough to kill,
     |  the only option is a graceful exit (use kill_all)
     |  
     |  Methods defined here:
     |  
     |  __init__(self, nthreads=1, *args, **kwargs)
     |  
     |  kill_all(self)
     |      attempt to gracefully kill the slaves
     |  
     |  put(self, task, *args, **kwargs)
     |      queue a task for execution
     |  
     |  start(self)
     |      set alive to True and start the slaves
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Threaded:
     |  
     |  get(self)
     |      if queue_output was specified, return a TaskInfo instance
    
    class Synchronized
     |  synchronized access to an object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, value=None)
     |  
     |  callattr(self, attr='__call__', *args, **kwargs)
     |  
     |  get(self)
     |  
     |  getattr(self, attr)
     |  
     |  set(self, value=None)
     |  
     |  setattr(self, attr, value=None)
     |  
     |  transform(self, func)
    
    class Task
     |  an interface for a task
     |  
     |  tasks don't have to subclass this,
     |  as a task is simply something callable
     |  
     |  note that __call__ accepts arguments
     |  
     |  Methods defined here:
     |  
     |  __call__(self, *args, **kwargs)
     |      execute the task
     |  
     |  __init__(self)
    
    class TaskInfo
     |  information about a task
     |  
     |  Methods defined here:
     |  
     |  __init__(self, task, output=None, *args, **kwargs)
    
    class Threaded
     |  base class for a thread allocator
     |  
     |  in order to preserve return values, this behaves like a queue:
     |  both the get and put operations are supported
     |  
     |  nthreads may be used to specify various behaviors:
     |      nthreads < 0
     |          -> a thread is spawned for each task
     |      nthreads == 0
     |          -> tasks are run in the current thread
     |      nthreads > 0
     |          -> up to nthreads tasks execute simultaneously
     |  
     |  Methods defined here:
     |  
     |  __init__(self, nthreads=-1, queue_output=False)
     |  
     |  get(self)
     |      if queue_output was specified, return a TaskInfo instance
     |  
     |  put(self, task, *args, **kwargs)
     |      allocate space for a task, optionally with arguments
