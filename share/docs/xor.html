<h1 id="%3Ccode%3Exor%3C/code%3E%20-%20securely%20XOR%20files%20to%20STDOUT"><code>xor</code> - securely XOR files to STDOUT</h1>

<p>Good encryption is tough to come by, and the theoretical usefulness of the One
Time Pad isn&#39;t all that easy in practice.  <code>xor</code> attempts to alleviate that.</p>

<p>Well, what makes this tool different from the tons of others out there?  Easy:
<ul>
<li>it&#39;s simple&#8211;the CLI is already minimal,</li>
<li>it&#39;s secure&#8211;the <em>single source file</em> is open, contains a breakdown on the
    precautions taken, plus it&#39;s easy to read&#47;verify,</li>
<li>and it <strong>supports multiple input files</strong>&#8211;this means you can <em>securely</em>
    encipher a plaintext with <strong>multiple keys</strong>.</p></li>
</ul>

<blockquote>
<p>In the name of security, this is extremely slow: in fact, it only encrypts a
single character at a time!  That way, if an attacker is able to recover
pages from its address space, loss of cryptographic secrets is minimized.
This approach is hugely advantageous over trust-based alternatives, such as a
dedicated cryptographic coprocessor, or using a dedicated machine for
cryptographic purposes for the reason that <strong><code>xor</code> expects to be attacked</strong>.</p>
</blockquote>

<p>Oh, and here&#39;s the full help text:
<pre>
securely XOR files to STDOUT
Usage: xor FILE...
</pre>
and an example:
</p>
<pre>

# create a plaintext file

<p>echo &#8220;some plaintext&#8221; &#62; ptext</p>

# generate random keys (of the same size: if they&#39;re too small, the XOR wraps
# around)

<p>COUNT=&#8220;$(wc -c ptext)&#8220;</p>

<p>for I in 1 2 3 4
do
    dd bs=1 count=&#8220;${COUNT}&#8220; if=&#47;dev&#47;urandom of=&#8220;key${I}&#8220;
done</p>

# generate a ciphertext

<p>xor key* ptext &#62; ctext</p>

# regenerate the plaintext

<p>xor key* ctext &#62; ptext.recovered</p>

# compare

<p>diff ptext*</p>
</pre>
