Help on package portscanner:

NAME
    portscanner

FILE
    portscanner.py

DESCRIPTION
    simple port scanning
    Usage: ./portscanner.py MODE/PROTO [OPTIONS]
    GENERAL OPTIONS
        -a, --address=ADDRESS|SUBNET
            the address (or subnet, using "ADDRESS/MASK" notation) to scan
        -j, --json
            print results in JSON format
            (defaults to a more readable format)
        -p, --ports=PORTS
            a comma-separated list of ports,
            with ranges denoted by hyphens
            e.g. for ports 1 to 3 and 5: "1-3,5"
    RESPONSE MODE OPTIONS
            --prompt=PROMPT
                optional prompt for a response
        -r, --recvlen=LENGTH
            number of bytes to receive
            (default attempts to read everything until the socket is closed)
    TCP PROTO MODES
        connect
            attempts to create a connection with each peer
        response
            attempts to create a connection with each peer,
            if specified, a prompt is sent before receiving bytes
    TCP PROTO OPTIONS
        -t, --timeout=TIMEOUT
            optional timeout
    UDP PROTO MODES
        response
            if specified, a prompt is sent before receiving bytes

CLASSES
    __builtin__.dict(__builtin__.object)
        ScanResults
    LoadDist
        FauxLoadDist
        ThreadedLoadDist
    Scan
        ResponseScan
            TCPResponseScan(ResponseScan, TCPScan)
            UDPResponseScan(ResponseScan, UDPScan)
        TCPScan
            TCPConnectScan
        UDPScan
    Scanner
    Subnet
    
    class FauxLoadDist(LoadDist)
     |  Methods defined here:
     |  
     |  __call__(self, func, *args, **kwargs)
     |      execute a task
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LoadDist:
     |  
     |  __init__(self)
    
    class LoadDist
     |  Methods defined here:
     |  
     |  __call__(self, func, *args, **kwargs)
     |      execute a task via the load distribution system
     |  
     |  __init__(self)
    
    class ResponseScan(Scan)
     |  Methods defined here:
     |  
     |  __init__(self, prompt=None, recvlen=-1)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Scan:
     |  
     |  __call__(self, addr)
     |      return ScanResults instance for the specified address
    
    class Scan
     |  Methods defined here:
     |  
     |  __call__(self, addr)
     |      return ScanResults instance for the specified address
     |  
     |  __init__(self)
    
    class ScanResults(__builtin__.dict)
     |  Method resolution order:
     |      ScanResults
     |      __builtin__.dict
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __str__(self)
     |  
     |  pretty_str(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from __builtin__.dict:
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __contains__(...)
     |      D.__contains__(k) -> True if D has a key k, else False
     |  
     |  __delitem__(...)
     |      x.__delitem__(y) <==> del x[y]
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see help(type(x)) for signature
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setitem__(...)
     |      x.__setitem__(i, y) <==> x[i]=y
     |  
     |  __sizeof__(...)
     |      D.__sizeof__() -> size of D in memory, in bytes
     |  
     |  clear(...)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  copy(...)
     |      D.copy() -> a shallow copy of D
     |  
     |  fromkeys(...)
     |      dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v.
     |      v defaults to None.
     |  
     |  get(...)
     |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.
     |  
     |  has_key(...)
     |      D.has_key(k) -> True if D has a key k, else False
     |  
     |  items(...)
     |      D.items() -> list of D's (key, value) pairs, as 2-tuples
     |  
     |  iteritems(...)
     |      D.iteritems() -> an iterator over the (key, value) items of D
     |  
     |  iterkeys(...)
     |      D.iterkeys() -> an iterator over the keys of D
     |  
     |  itervalues(...)
     |      D.itervalues() -> an iterator over the values of D
     |  
     |  keys(...)
     |      D.keys() -> list of D's keys
     |  
     |  pop(...)
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
     |      If key is not found, d is returned if given, otherwise KeyError is raised
     |  
     |  popitem(...)
     |      D.popitem() -> (k, v), remove and return some (key, value) pair as a
     |      2-tuple; but raise KeyError if D is empty.
     |  
     |  setdefault(...)
     |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
     |  
     |  update(...)
     |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
     |      If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
     |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
     |      In either case, this is followed by: for k in F: D[k] = F[k]
     |  
     |  values(...)
     |      D.values() -> list of D's values
     |  
     |  viewitems(...)
     |      D.viewitems() -> a set-like object providing a view on D's items
     |  
     |  viewkeys(...)
     |      D.viewkeys() -> a set-like object providing a view on D's keys
     |  
     |  viewvalues(...)
     |      D.viewvalues() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from __builtin__.dict:
     |  
     |  __hash__ = None
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class Scanner
     |  Methods defined here:
     |  
     |  __call__(self, addrs)
     |      generate ScanResult instances for the specified addresses
     |  
     |  __init__(self, loaddist=None, *scans)
    
    class Subnet
     |  Methods defined here:
     |  
     |  __init__(self, addr, mask)
     |  
     |  __iter__(self)
     |  
     |  next(self)
    
    class TCPConnectScan(TCPScan)
     |  obtains results of the form:
     |      ScanResults(connected = <boolean>, peername = <address>,
     |          scantype = "TCPConnectScan", timeout = <number>)
     |  
     |  Method resolution order:
     |      TCPConnectScan
     |      TCPScan
     |      Scan
     |  
     |  Methods defined here:
     |  
     |  __call__(self, addr)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from TCPScan:
     |  
     |  __init__(self, timeout=None)
    
    class TCPResponseScan(ResponseScan, TCPScan)
     |  obtains results of the form:
     |      ScanResults(connected = <boolean>, peername = <address>,
     |          prompt = <null or string>, recvlen = <number>,
     |          response = <null or string>, scantype = "TCPResponseScan",
     |          timeout = <number>)
     |  
     |  Method resolution order:
     |      TCPResponseScan
     |      ResponseScan
     |      Scan
     |      TCPScan
     |  
     |  Methods defined here:
     |  
     |  __call__(self, addr)
     |  
     |  __init__(self, prompt=None, recvlen=-1, timeout=None)
    
    class TCPScan(Scan)
     |  Methods defined here:
     |  
     |  __init__(self, timeout=None)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Scan:
     |  
     |  __call__(self, addr)
     |      return ScanResults instance for the specified address
    
    class ThreadedLoadDist(LoadDist)
     |  Methods defined here:
     |  
     |  __call__(self, func, *args, **kwargs)
     |  
     |  __init__(self, capacity=10)
    
    class UDPResponseScan(ResponseScan, UDPScan)
     |  obtains results of the form:
     |      ScanResults(connected = <boolean>, peername = <address>,
     |          prompt = <null or string>, recvlen = <number>,
     |          response = <null or string>, scantype = "UDPresponseScan",
     |          sent = <number>)
     |  
     |  Method resolution order:
     |      UDPResponseScan
     |      ResponseScan
     |      Scan
     |      UDPScan
     |  
     |  Methods defined here:
     |  
     |  __call__(self, addr)
     |  
     |  __init__(self, prompt=None, recvlen=None)
    
    class UDPScan(Scan)
     |  Methods inherited from Scan:
     |  
     |  __call__(self, addr)
     |      return ScanResults instance for the specified address
     |  
     |  __init__(self)

FUNCTIONS
    main(argv)

DATA
    PROMPT = None
    RECVLEN = -1
    THREADEDLOADDIST_CAPACITY = 10
    TIMEOUT = None
